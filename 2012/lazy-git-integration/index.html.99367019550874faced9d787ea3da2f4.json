{"head":{"layout":"Post","date":"2012-08-03T00:00:00.000Z","tags":["git","deployment","workflow"],"description":"How to integrate GIT in a team that is not ready to fully use VCS yet","title":"Lazy GIT integration","lastmod":"2013-06-20T00:00:00.000Z","route":"2012/lazy-git-integration","image":"/assets/lazy-git-integration.jpeg","imageUrl":"https://unsplash.com/photos/TYIzeCiZ_60","imageAuthor":"Karl Fredrickson","imageAuthorUrl":"https://unsplash.com/@kfred","imageProviderName":"Unsplash","imageProviderUrl":"https://unsplash.com/","primaryColor":"rgba(109, 63, 34, .9)","secondaryColor":"#e1c788","linksColor":"#680148","linksHoverColor":"#000000"},"body":"<div class=\"warning-box\">\n<p>Update on 20/06/2013</p>\n<p>Add <a href=\"#deploy-tip\">custom deployment strategy tip</a></p>\n</div>\n<h2 id=\"preface\"><a href=\"#preface\" class=\"phenomic-HeadingAnchor\">#</a>Preface</h2>\n<p>Recently I was challenged to integrate source code versioning and efficient\nwebsite deployment in a team that was not ready to switch from old-school FTP deployment.\nI call it \"lazy integration\" because it is indeed full featured integration\nwhile it doesn't force anyone in the team using GIT at all.</p>\n<p>This post contains information on how I did it and aims to be a how-to reminder\nfor myself in case I will ever do this again. It works for me just fine but\nI can't guarantee that by following this tutorial you won't harm your software\nso use this tutorial on your own risk.</p>\n<h2 id=\"overview\"><a href=\"#overview\" class=\"phenomic-HeadingAnchor\">#</a>Overview</h2>\n<p>Let's take a brief look at what we're going to do and how things are going to work after\nwe finish.</p>\n<p>First, a bare repository is initialized out of production source code directory, some hooks\nare being installed and repo can now be cloned to dev stations.</p>\n<p>Pushing modifications to bare repository activates a hook\n(<a href=\"https://gist.github.com/3175467\">pre-receive</a>) that checks for any\nlocal working directory (production source code) changes against HEAD (latest commit).\nIf no changes were found it just quits with no error and another hook\n(<a href=\"https://gist.github.com/3175502\">post-receive</a>)\napplies pushed commits to the working directory (production source code).\nHowever, if any changes were detected they are submitted to a newly created commit and\nhook quits with an error. At this point developer should bring that commit to\nhis cloned repo (by executing, let's say, PULL command) and PUSH once again.</p>\n<p>What is so special in this flow? Well, it allows you to make changes directly on\nPRODUCTION source code while still being able using GIT to track and deploy your\nmodifications. Some teams need just that but please make sure to read some of my thoughts\non that in the end of this post.</p>\n<h2 id=\"get-started\"><a href=\"#get-started\" class=\"phenomic-HeadingAnchor\">#</a>Get started</h2>\n<p>Let's get our hands dirty and try a real example.</p>\n<p>Although I couldn't think of any software project that wouldn't fit this integration, I\nexpect you to make required adjustments for your specific scenario if you decided to apply this\nintegration to your project.</p>\n<p>In our example we assume that we have a simple static website, it's\nwebroot path is <code>/var/htdocs/myproject</code> on PRODUCTION server (also we assume that\nyou have SSH access to this server).</p>\n<p>Initialize a GIT repository out of source code we have in <code>myproject</code> directory:</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">cd</span> /var/htdocs\nmkdir myproject.git &#x26;&#x26; <span class=\"hljs-built_in\">cd</span> myproject.git\ngit init --bare\ngit --work-tree=../myproject add .\ngit --work-tree=../myproject commit -m<span class=\"hljs-string\">'Initial commit'</span></code></pre>\n<p>Setup hooks. First, download\n<a href=\"https://gist.github.com/3175467\">pre-receive</a> hook as\n<code>/var/htdocs/myproject.git/hooks/pre-receive</code> and\nmake it executable:</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">cd</span> /var/htdocs/myproject.git/hooks\nwget http://bit.ly/19l9tpg -O pre-receive --no-check-certificate\nchmod +x pre-receive</code></pre>\n<p>Next, download\n<a href=\"https://gist.github.com/3175502\">post-receive</a> hook\nas <code>/var/htdocs/myproject.git/hooks/post-receive</code> and\nmake it executable:</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">cd</span> /var/htdocs/myproject.git/hooks\nwget http://bit.ly/12XVJ57 -O post-receive --no-check-certificate\nchmod +x post-receive</code></pre>\n<p>Now open both of the hooks in your editor of choice and make sure that the value of <code>WORKTREE</code> variable\nrepresents the absolute or relative path (relatively to <code>/var/htdocs/myproject.git/</code>)\nof your source code directory.</p>\n<p>You're ready to clone bare repository to your local dev station and PUSH from\nit.</p>\n<p>Additionally, you could set some restrictions on your bare repository (I find\nthem reasonable on PRODUCTION bare repository):</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">cd</span> /var/htdocs/myproject.git\ngit config receive.denyDeletes <span class=\"hljs-literal\">true</span>\ngit config receive.denyNonFastForwards <span class=\"hljs-literal\">true</span></code></pre>\n<p><code>denyDeletes</code> set to <code>true</code> denies any attempts to delete a branch remotely.</p>\n<p><code>denyNonFastForwards</code> set to <code>true</code> denies any attempts to delete/replace\nexisting commits remotely.</p>\n<p><a name=\"deploy-tip\"></a></p>\n<h2 id=\"custom-deployment\"><a href=\"#custom-deployment\" class=\"phenomic-HeadingAnchor\">#</a>Custom deployment</h2>\n<p>If updating working directory is not enough for your deployment needs I\nsuggest commiting a script which will do all is required and executing it\nin <code>post-receive</code> hook right after working tree update, like so:</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># update the working tree</span>\nGIT_WORK_TREE=<span class=\"hljs-variable\">$WORKTREE</span> git checkout -f\n\n<span class=\"hljs-comment\"># run custom deploy script</span>\ndeploy_script=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$WORKTREE</span>/deploy.sh\"</span>\n<span class=\"hljs-keyword\">if</span> [ -e <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$deploy_script</span>\"</span> ]\n<span class=\"hljs-keyword\">then</span>\n  . <span class=\"hljs-variable\">$deploy_script</span>\n<span class=\"hljs-keyword\">fi</span></code></pre>\n<p>In this example I'm executing <code>deploy.sh</code> script which resides in the root of\nmy repository. Which means I can control my deployment right from my\nlocal repo and any changes to script take place immediately. It's very\npowerful.</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Although I believe that any source code deployment should be done via VCS like\nGIT I know that there are not few programmers out there who're not ready to\nwaste their time learning VCS and they feel themselves uncomfortable with the\nfact that any PRODUCTION update should go through a \"long\" deployment process.</p>\n<p>So, even though I'm glad I could find a solution for teams with weak workflow,\nI highly recommend changing the workflow rather than using this kind of solution.</p>\n<p>And what kind of deployment strategy are you using in your projects?</p>\n","__filename":"posts/2012-08-03-lazy-git-integration.md","__url":"/2012/lazy-git-integration/","__resourceUrl":"/2012/lazy-git-integration/index.html","__dataUrl":"/2012/lazy-git-integration/index.html.99367019550874faced9d787ea3da2f4.json"}